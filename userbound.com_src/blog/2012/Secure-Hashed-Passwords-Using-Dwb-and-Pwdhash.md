---
page:
  variables:
    title: Secure Hashed Passwords Using Dwb and Pwdhash 
    date: 2012-04-25
    time: 8:44PM
---
[Password hashing](http://en.wikipedia.org/wiki/Cryptographic_hash_function) services like [PwdHash](https://pwdhash.com) and [SuperGenPass](http://supergenpass.com) allow you enter your password in the password field of any site and then by way of some Javascript your master password is replaced with its hashed counterpart. My problem with these services is that they are fundamentally insecure due to their implementation. Both PwdHash and SuperGenPass rely on replacement of your master password via Javascript after it has already been entered on the site. 

Anyone who's spent any time with Javascript knows it would not hard be hard to [retrieve that master password](http://kuza55.blogspot.com/2007/02/attacking-pwdhash-firefox-extension.html) that you entered. Thus, PwdHash and SuperGenPass's hashing implementations only work if you trust the Javascript of every site you visit. How could this ever be classified as a solution to the common household hashing problem?

**A Better Hashing Implementation**: 
My solution involves using a browser that can offload the hashing task to another program. Using the browser, [Dwb](http://portix.bitbucket.org/dwb/), you can very easily set it up so that an external script passes in the hashed password to the browser and thus the master password is never exposed.

[hash](https://github.com/mil/configs-and-bins/blob/master/configs/.config/dwb/userscripts/hash) (*~/.config/userscripts/hash*)

<pre class="sh_ruby">
#!/usr/bin/ruby
require 'uri'
site = (URI).parse(ENV['DWB_URI']).host
password = `zenity --password`
hashedPassword = `node ~/bin/pwdhash.js #{site} #{password}`.chomp!
IO.binwrite(ENV['DWB_FIFO'], "open javascript:document.activeElement.value = '#{hashedPassword}")
</pre>

This hash userscript, to be run from Dwb, essentially just uses [zenity](http://library.gnome.org/users/zenity/stable) ([Xdialog](http://xdialog.free.fr) works here too) to prompt the user for their master password. Then their master password along with the user's current site is run through the commandline tool [pwdhash.js](https://github.com/mil/configs-and-bins/blob/master/bins/pwdhash.js). [pwdhash.js](https://github.com/mil/configs-and-bins/blob/master/bins/pwdhash.js) is just a simple Node.js port I made of the [PwdHash Browser Javascript Implementation](https://pwdhash.com). Once the hashed password is returned from pwdhash.js, Dwb is then told to run some Javascript to insert *only the that hashed password* back into the currently selected password field of the current site.

**Use Case:**
In Dwb, once on a password field, in command mode you type the command ":hash" and a password entry dialog is spawned.

![Pwdhash Password Entry Via Zenity](/images/pwdhash-password-entry.png)

You type your password in the dialog (generated by zenity) and then once you hit enter your hashed password is inserted into the password field.

![Pwdhash Hashed Password on Google.Com](/images/pwdhash-password.png)

And there you have it - a more secure hashing implementation using Dwb in combination with PwdHash's algorithm! No long are you exposing your master password to arbitrary Javascript.
